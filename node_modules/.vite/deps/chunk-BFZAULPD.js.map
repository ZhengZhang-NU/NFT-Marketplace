{
  "version": 3,
  "sources": ["../../viem/src/errors/version.ts", "../../viem/src/errors/utils.ts", "../../viem/src/errors/base.ts", "../../viem/src/utils/data/isHex.ts", "../../viem/src/errors/chain.ts", "../../viem/src/utils/chain.ts", "../../viem/src/utils/formatters/format.ts", "../../viem/src/utils/data/size.ts", "../../viem/src/utils/data/trim.ts", "../../viem/src/errors/data.ts", "../../viem/src/utils/data/pad.ts", "../../viem/src/errors/encoding.ts", "../../viem/src/utils/encoding/toBytes.ts", "../../viem/src/utils/encoding/fromHex.ts", "../../viem/src/utils/encoding/toHex.ts", "../../viem/src/utils/formatters/transactionRequest.ts"],
  "sourcesContent": ["export const version = '0.3.50'\n", "import type { Address } from 'abitype'\n\nimport { version } from './version.js'\n\nexport const getContractAddress = (address: Address) => address\nexport const getUrl = (url: string) => url\nexport const getVersion = () => `viem@${version}`\n", "import { getVersion } from './utils.js'\n\ntype BaseErrorParameters = {\n  docsPath?: string\n  docsSlug?: string\n  metaMessages?: string[]\n} & (\n  | {\n      cause?: never\n      details?: string\n    }\n  | {\n      cause: BaseError | Error\n      details?: never\n    }\n)\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n\n  override name = 'ViemError'\n  version = getVersion()\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    super()\n\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n        ? args.cause.message\n        : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n\n    this.message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath\n        ? [\n            `Docs: https://viem.sh${docsPath}.html${\n              args.docsSlug ? `#${args.docsSlug}` : ''\n            }`,\n          ]\n        : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: ${this.version}`,\n    ].join('\\n')\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n\n  walk(fn?: (err: unknown) => boolean) {\n    return this.#walk(this, fn)\n  }\n\n  #walk(err: unknown, fn?: (err: unknown) => boolean): unknown {\n    if (fn?.(err)) return err\n    if ((err as Error).cause) return this.#walk((err as Error).cause, fn)\n    return err\n  }\n}\n", "import type { Hex } from '../../types/misc.js'\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n", "import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport class ChainDoesNotSupportContract extends BaseError {\n  override name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint\n    chain: Chain\n    contract: { name: string; blockCreated?: number }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport class ChainMismatchError extends BaseError {\n  override name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id} – ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class ChainNotFoundError extends BaseError {\n  override name = 'ChainNotFoundError'\n\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class ClientChainNotConfiguredError extends BaseError {\n  override name = 'ClientChainNotConfiguredError'\n\n  constructor() {\n    super('No chain was provided to the Client.')\n  }\n}\n\nexport class InvalidChainIdError extends BaseError {\n  override name = 'InvalidChainIdError'\n\n  constructor({ chainId }: { chainId: number }) {\n    super(`Chain ID \"${chainId}\" is invalid.`)\n  }\n}\n", "import {\n  ChainDoesNotSupportContract,\n  ChainMismatchError,\n  ChainNotFoundError,\n} from '../errors/chain.js'\nimport type { Chain, ChainContract } from '../types/chain.js'\nimport type { Formatters } from '../types/formatter.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain\n  currentChainId: number\n}\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n\nexport function defineChain<\n  TFormatters extends Formatters = Formatters,\n  TChain extends Chain<TFormatters> = Chain<TFormatters>,\n>(chain: TChain) {\n  return chain\n}\n\nexport function getChainContractAddress({\n  blockNumber,\n  chain,\n  contract: name,\n}: {\n  blockNumber?: bigint\n  chain: Chain\n  contract: string\n}) {\n  const contract = (chain?.contracts as Record<string, ChainContract>)?.[name]\n  if (!contract)\n    throw new ChainDoesNotSupportContract({\n      chain,\n      contract: { name },\n    })\n\n  if (\n    blockNumber &&\n    contract.blockCreated &&\n    contract.blockCreated > blockNumber\n  )\n    throw new ChainDoesNotSupportContract({\n      blockNumber,\n      chain,\n      contract: {\n        name,\n        blockCreated: contract.blockCreated,\n      },\n    })\n\n  return contract.address\n}\n", "import type { Chain } from '../../types/chain.js'\nimport type { Formatter } from '../../types/formatter.js'\nimport type { OptionalNullable } from '../../types/utils.js'\n\nexport type ExtractFormatter<\n  TChain extends Chain,\n  TKey extends keyof NonNullable<TChain['formatters']>,\n  TFallbackFormatter extends Formatter = Formatter,\n> = NonNullable<TChain['formatters']>[TKey] extends NonNullable<unknown>\n  ? NonNullable<TChain['formatters']>[TKey]\n  : TFallbackFormatter\n\nexport type FormatOptions<TSource, TTarget> = {\n  formatter: Formatter<TSource, TTarget>\n}\n\n/**\n * Creates a type that is the result of applying `TFormatter` to `TSource`.\n *\n * @example\n * Formatted<() => { a: undefined, b: bigint }, { a: bigint }>\n * => { a: undefined, b: bigint }\n *\n * @example\n * Formatted<() => {}, { a: bigint }>\n * => { a: bigint }\n *\n * @example\n * Formatted<() => { a: bigint | undefined, b: bigint }, { a: bigint, b: bigint }, true>\n * => { a?: bigint | undefined, b: bigint }\n */\nexport type Formatted<\n  TFormatter,\n  TFallback,\n  TAllowOptional = false,\n  TUseParameters = false,\n> = TFormatter extends Formatter\n  ? // If Formatter attributes exist, attach them; otherwise attach the Target type (e.g. Block).\n    ReturnType<TFormatter> extends Record<string, never>\n    ? TFallback\n    : TAllowOptional extends true\n    ? OptionalNullable<\n        TUseParameters extends true\n          ? Parameters<TFormatter>[0]\n          : ReturnType<TFormatter>\n      >\n    : TUseParameters extends true\n    ? Parameters<TFormatter>[0]\n    : ReturnType<TFormatter>\n  : never\n\n/**\n * @description Formats a data object using the given replacer and an optional formatter.\n */\nexport function format<\n  TFormatter,\n  TSource extends Record<string, any>,\n  TTarget,\n>(data: TSource, { formatter }: FormatOptions<TSource, TTarget>) {\n  return formatter(data) as Formatted<TFormatter, TTarget>\n}\n\nexport function defineFormatter<\n  TSource extends Record<string, unknown>,\n  TFormatted,\n>({\n  format,\n}: {\n  format: (data: TSource) => TFormatted\n}) {\n  return <\n      TFormat extends Formatter<\n        TSource,\n        Partial<TFormatted> & { [key: string]: unknown }\n      >,\n      TExclude extends (keyof TSource)[] = [],\n    >({\n      exclude,\n      format: formatOverride,\n    }: {\n      exclude?: TExclude\n      format?: TFormat\n    }) =>\n    (data: TSource & { [key: string]: unknown }) => {\n      const formatted = format(data)\n      if (exclude) {\n        for (const key of exclude) {\n          delete (formatted as any)[key]\n        }\n      }\n      return {\n        ...formatted,\n        ...formatOverride?.(data),\n      } as TFormatted &\n        ReturnType<TFormat> & {\n          [K in TExclude[number]]: never\n        }\n    }\n}\n", "import type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n", "import type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right'\n}\nexport type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function trim<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>\n  }\n  return data as TrimReturnType<TValue>\n}\n", "import { BaseError } from './base.js'\n\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  override name = 'SliceOffsetOutOfBoundsError'\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n    )\n  }\n}\n\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  override name = 'SizeExceedsPaddingSizeError'\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n    )\n  }\n}\n", "import { SizeExceedsPaddingSizeError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right'\n  size?: number | null\n}\nexport type PadReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function pad<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<TValue> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n}\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n", "import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport class DataLengthTooLongError extends BaseError {\n  override name = 'DataLengthTooLongError'\n  constructor({ consumed, length }: { consumed: number; length: number }) {\n    super(\n      `Consumed bytes (${consumed}) is shorter than data length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class DataLengthTooShortError extends BaseError {\n  override name = 'DataLengthTooShortError'\n  constructor({ length, dataLength }: { length: number; dataLength: number }) {\n    super(\n      `Data length (${dataLength - 1}) is shorter than prefix length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class IntegerOutOfRangeError extends BaseError {\n  override name = 'IntegerOutOfRangeError'\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string\n    min: string\n    signed?: boolean\n    size?: number\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n    )\n  }\n}\n\nexport class InvalidBytesBooleanError extends BaseError {\n  override name = 'InvalidBytesBooleanError'\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n    )\n  }\n}\n\nexport class InvalidHexBooleanError extends BaseError {\n  override name = 'InvalidHexBooleanError'\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n    )\n  }\n}\n\nexport class InvalidHexValueError extends BaseError {\n  override name = 'InvalidHexValueError'\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n    )\n  }\n}\n\nexport class OffsetOutOfBoundsError extends BaseError {\n  override name = 'OffsetOutOfBoundsError'\n  constructor({ nextOffset, offset }: { nextOffset: number; offset: number }) {\n    super(\n      `Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`,\n    )\n  }\n}\n\nexport class SizeOverflowError extends BaseError {\n  override name = 'SizeOverflowError'\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n    )\n  }\n}\n", "import { BaseError } from '../../errors/base.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\nimport { type NumberToHexOpts, numberToHex } from './toHex.js'\n\nconst encoder = new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToHexOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const bytes = new Uint8Array(hexString.length / 2)\n  for (let index = 0; index < bytes.length; index++) {\n    const start = index * 2\n    const hexByte = hexString.slice(start, start + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0)\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexByte}\" in \"${hexString}\").`,\n      )\n    bytes[index] = byte\n  }\n  return bytes\n}\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n", "import {\n  InvalidHexBooleanError,\n  SizeOverflowError,\n} from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { size as size_ } from '../data/size.js'\nimport { trim } from '../data/trim.js'\n\nimport { hexToBytes } from './toBytes.js'\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<TTo>\n  return hexToBytes(hex, opts) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n", "import { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\n\nconst hexes = Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let hexString = ''\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]]\n  }\n\n  const hex: Hex = `0x${hexString}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nconst encoder = new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n", "import type { Chain } from '../../types/chain.js'\nimport type { Formatter, Formatters } from '../../types/formatter.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport { numberToHex } from '../encoding/toHex.js'\n\nimport {\n  type ExtractFormatter,\n  type Formatted,\n  defineFormatter,\n} from './format.js'\n\nexport type TransactionRequestFormatter<\n  TChain extends Chain | undefined = Chain,\n> = TChain extends Chain\n  ? ExtractFormatter<\n      TChain,\n      'transactionRequest',\n      NonNullable<Formatters['transactionRequest']>\n    >\n  : Formatters['transactionRequest']\n\nexport type FormattedTransactionRequest<\n  TFormatter extends Formatter | undefined = Formatter,\n> = Formatted<TFormatter, RpcTransactionRequest>\n\nexport function formatTransactionRequest(\n  transactionRequest: Partial<TransactionRequest>,\n) {\n  return {\n    ...transactionRequest,\n    gas:\n      typeof transactionRequest.gas !== 'undefined'\n        ? numberToHex(transactionRequest.gas)\n        : undefined,\n    gasPrice:\n      typeof transactionRequest.gasPrice !== 'undefined'\n        ? numberToHex(transactionRequest.gasPrice)\n        : undefined,\n    maxFeePerGas:\n      typeof transactionRequest.maxFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxFeePerGas)\n        : undefined,\n    maxPriorityFeePerGas:\n      typeof transactionRequest.maxPriorityFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxPriorityFeePerGas)\n        : undefined,\n    nonce:\n      typeof transactionRequest.nonce !== 'undefined'\n        ? numberToHex(transactionRequest.nonce)\n        : undefined,\n    value:\n      typeof transactionRequest.value !== 'undefined'\n        ? numberToHex(transactionRequest.value)\n        : undefined,\n  } as RpcTransactionRequest\n}\n\nexport const defineTransactionRequest = defineFormatter({\n  format: formatTransactionRequest,\n})\n"],
  "mappings": "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",
  "names": ["_BaseError_walk", "format", "size", "size", "size", "size", "size", "size", "encoder"]
}
