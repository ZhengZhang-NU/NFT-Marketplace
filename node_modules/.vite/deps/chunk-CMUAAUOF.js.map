{
  "version": 3,
  "sources": ["../../viem/src/utils/data/concat.ts", "../../viem/src/utils/abi/formatAbiItem.ts", "../../viem/src/errors/abi.ts", "../../viem/src/errors/address.ts", "../../viem/src/utils/address/isAddress.ts", "../../viem/src/utils/data/slice.ts", "../../viem/src/utils/abi/encodeAbiParameters.ts", "../../viem/src/constants/solidity.ts", "../../viem/src/utils/contract/extractFunctionParts.ts", "../../viem/node_modules/@noble/hashes/src/_u64.ts", "../../viem/node_modules/@noble/hashes/src/sha3.ts", "../../viem/src/utils/hash/keccak256.ts", "../../viem/src/utils/hash/hashFunction.ts", "../../viem/src/utils/hash/getFunctionSelector.ts", "../../viem/src/utils/address/getAddress.ts", "../../viem/src/utils/abi/decodeAbiParameters.ts", "../../viem/src/utils/abi/decodeErrorResult.ts", "../../viem/src/utils/stringify.ts", "../../viem/src/errors/request.ts", "../../viem/src/accounts/utils/parseAccount.ts", "../../viem/src/constants/abis.ts", "../../viem/src/constants/contract.ts", "../../viem/src/utils/abi/formatAbiItemWithArgs.ts", "../../viem/src/utils/abi/getAbiItem.ts", "../../viem/src/constants/unit.ts", "../../viem/src/utils/unit/formatUnits.ts", "../../viem/src/utils/unit/formatEther.ts", "../../viem/src/utils/unit/formatGwei.ts", "../../viem/src/errors/transaction.ts", "../../viem/src/errors/contract.ts", "../../viem/src/utils/abi/decodeFunctionResult.ts", "../../viem/src/utils/abi/encodeFunctionData.ts", "../../viem/src/errors/node.ts", "../../viem/src/errors/rpc.ts", "../../viem/src/utils/errors/getNodeError.ts", "../../viem/src/utils/errors/getCallError.ts", "../../viem/src/utils/formatters/extract.ts", "../../viem/src/utils/promise/createBatchScheduler.ts", "../../viem/src/utils/transaction/assertRequest.ts", "../../viem/src/actions/public/call.ts"],
  "sourcesContent": ["import type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<TValue extends Hex | ByteArray> =\n  TValue extends Hex ? Hex : ByteArray\n\nexport function concat<TValue extends Hex | ByteArray>(\n  values: TValue[],\n): ConcatReturnType<TValue> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as Hex[]) as ConcatReturnType<TValue>\n  return concatBytes(values as ByteArray[]) as ConcatReturnType<TValue>\n}\n\nexport function concatBytes(values: ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport function concatHex(values: Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n", "import type { AbiParameter } from 'abitype'\n\nimport { InvalidDefinitionTypeError } from '../../errors/abi.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n", "import type { AbiParameter } from 'abitype'\n\nimport type { AbiItem } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(errorName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(eventName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(functionName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiItem\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport class InvalidAddressError extends BaseError {\n  override name = 'InvalidAddressError'\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`)\n  }\n}\n", "import type { Address } from 'abitype'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\nexport function isAddress(address: string): address is Address {\n  return addressRegex.test(address)\n}\n", "import { SliceOffsetOutOfBoundsError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\nimport { size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nfunction assertEndOffset(value: Hex | ByteArray, start?: number, end?: number) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  AbiEncodingBytesSizeMismatchError,\n  AbiEncodingLengthMismatchError,\n  InvalidAbiEncodingTypeError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concat } from '../data/concat.js'\nimport { padHex } from '../data/pad.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: Narrow<TParams>,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nfunction prepareParams<TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: Narrow<TParams>\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nfunction prepareParam<TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nfunction encodeArray<TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nfunction encodeBytes<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [_, size_] = param.type.split('bytes')\n  if (!size_) {\n    const partsLength = Math.ceil(size(value) / 32)\n    const parts: Hex[] = []\n    for (let i = 0; i < partsLength; i++) {\n      parts.push(\n        padHex(slice(value, i * 32, (i + 1) * 32), {\n          dir: 'right',\n        }),\n      )\n    }\n    return {\n      dynamic: true,\n      encoded: concat([\n        padHex(numberToHex(size(value), { size: 32 })),\n        ...parts,\n      ]),\n    }\n  }\n  if (size(value) !== parseInt(size_))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(size_),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nfunction encodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n", "import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n", "const paramsRegex = /((function|event)\\s)?(.*)(\\((.*)\\))/\n\nexport function extractFunctionParts(def: string) {\n  const parts = def.match(paramsRegex)\n  const type = parts?.[2] || undefined\n  const name = parts?.[3]\n  const params = parts?.[5] || undefined\n  return { type, name, params }\n}\n\nexport function extractFunctionName(def: string) {\n  return extractFunctionParts(def).name\n}\n\nexport function extractFunctionParams(def: string) {\n  const params = extractFunctionParts(def).params\n  const splitParams = params?.split(',').map((x) => x.trim().split(' '))\n  return splitParams?.map((param) => ({\n    type: param[0],\n    name: param[1] === 'indexed' ? param[2] : param[1],\n    ...(param[1] === 'indexed' ? { indexed: true } : {}),\n  }))\n}\n\nexport function extractFunctionType(def: string) {\n  return extractFunctionParts(def).type\n}\n", "const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nexport function split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nexport const toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h: number, l: number) => l;\nconst rotr32L = (h: number, l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    assert.number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    assert.exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructorWithOpts<Keccak, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\n", "import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n", "import {\n  extractFunctionName,\n  extractFunctionParams,\n} from '../contract/extractFunctionParts.js'\nimport { toBytes } from '../encoding/toBytes.js'\n\nimport { keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport function hashFunction(def: string) {\n  const name = extractFunctionName(def)\n  const params = extractFunctionParams(def) || []\n  return hash(`${name}(${params.map(({ type }) => type).join(',')})`)\n}\n", "import { slice } from '../data/slice.js'\n\nimport { hashFunction } from './hashFunction.js'\n\nexport const getFunctionSelector = (fn: string) => slice(hashFunction(fn), 0, 4)\n", "import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { stringToBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function checksumAddress(address_: Address, chainId?: number): Address {\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport function getAddress(address: string, chainId?: number): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport { checksumAddress } from '../address/getAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { trim } from '../data/trim.js'\nimport {\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: Narrow<TParams>, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n", "import type {\n  Abi,\n  ExtractAbiError,\n  ExtractAbiErrorNames,\n  Narrow,\n} from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  AbiErrorSignatureNotFoundError,\n} from '../../errors/abi.js'\nimport type { AbiItem, GetErrorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { slice } from '../data/slice.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = { abi?: Narrow<TAbi>; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  _ErrorNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiErrorNames<TAbi>\n    : string,\n> = {\n  [TName in _ErrorNames]: {\n    abiItem: TAbi extends Abi ? ExtractAbiError<TAbi, TName> : AbiItem\n    args: GetErrorArgs<TAbi, TName>['args']\n    errorName: TName\n  }\n}[_ErrorNames]\n\nexport function decodeErrorResult<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  data,\n}: DecodeErrorResultParameters<TAbi>): DecodeErrorResultReturnType<TAbi> {\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...((abi as Abi) || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n      ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<TAbi>\n}\n", "export const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n", "import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class HttpRequestError extends BaseError {\n  override name = 'HttpRequestError'\n\n  body?: { [key: string]: unknown }\n  headers?: Headers\n  status?: number\n  url: string\n\n  constructor({\n    body,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [key: string]: unknown }\n    details?: string\n    headers?: Headers\n    status?: number\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport class WebSocketRequestError extends BaseError {\n  override name = 'WebSocketRequestError'\n\n  constructor({\n    body,\n    details,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    details: string\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      details,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n\nexport class RpcRequestError extends BaseError {\n  override name = 'RpcRequestError'\n\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n    this.code = error.code\n  }\n}\n\nexport class TimeoutError extends BaseError {\n  override name = 'TimeoutError'\n\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../types.js'\n\nexport function parseAccount(account: Address | Account): Account {\n  if (typeof account === 'string') return { address: account, type: 'json-rpc' }\n  return account\n}\n", "/* [Multicall3](https://github.com/mds1/multicall) */\nexport const multicall3Abi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            name: 'target',\n            type: 'address',\n          },\n          {\n            name: 'allowFailure',\n            type: 'bool',\n          },\n          {\n            name: 'callData',\n            type: 'bytes',\n          },\n        ],\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'aggregate3',\n    outputs: [\n      {\n        components: [\n          {\n            name: 'success',\n            type: 'bool',\n          },\n          {\n            name: 'returnData',\n            type: 'bytes',\n          },\n        ],\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nexport const universalResolverAbi = [\n  {\n    name: 'resolve',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes' },\n      { name: 'data', type: 'bytes' },\n    ],\n    outputs: [\n      { name: '', type: 'bytes' },\n      { name: 'address', type: 'address' },\n    ],\n  },\n] as const\n\nexport const textResolverAbi = [\n  {\n    name: 'text',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes32' },\n      { name: 'key', type: 'string' },\n    ],\n    outputs: [{ name: '', type: 'string' }],\n  },\n] as const\n\nexport const singleAddressResolverAbi = [\n  {\n    name: 'addr',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ name: 'name', type: 'bytes32' }],\n    outputs: [{ name: '', type: 'address' }],\n  },\n] as const\n\n// ERC-1271\n// isValidSignature(bytes32 hash, bytes signature) → bytes4 magicValue\nexport const smartAccountAbi = [\n  {\n    name: 'isValidSignature',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'hash', type: 'bytes32' },\n      { name: 'signature', type: 'bytes' },\n    ],\n    outputs: [{ name: '', type: 'bytes4' }],\n  },\n] as const\n\n// ERC-6492 - universal deployless signature validator contract\n// constructor(address _signer, bytes32 _hash, bytes _signature) → bytes4 returnValue\n// returnValue is either 0x1 (valid) or 0x0 (invalid)\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n] as const\n", "export const aggregate3Signature = '0x82ad56cb'\n", "import type { AbiParameter } from 'abitype'\n\nimport type { AbiItem } from '../../types/contract.js'\nimport { stringify } from '../stringify.js'\n\nexport function formatAbiItemWithArgs({\n  abiItem,\n  args,\n  includeFunctionName = true,\n  includeName = false,\n}: {\n  abiItem: AbiItem\n  args: readonly unknown[]\n  includeFunctionName?: boolean\n  includeName?: boolean\n}) {\n  if (!('name' in abiItem)) return\n  if (!('inputs' in abiItem)) return\n  if (!abiItem.inputs) return\n  return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n    .map(\n      (input: AbiParameter, i: number) =>\n        `${includeName && input.name ? `${input.name}: ` : ''}${\n          typeof args[i] === 'object' ? stringify(args[i]) : args[i]\n        }`,\n    )\n    .join(', ')})`\n}\n", "import type { Abi, AbiParameter, Address, Narrow } from 'abitype'\n\nimport type { GetFunctionArgs, InferItemName } from '../../types/contract.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  name: InferItemName<TAbi, TItemName>\n} & Partial<GetFunctionArgs<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const abiItems = (abi as Abi).filter((x) => 'name' in x && x.name === name)\n\n  if (abiItems.length === 0) return undefined as any\n  if (abiItems.length === 1) return abiItems[0] as any\n\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) return abiItem as any\n  }\n  return abiItems[0] as any\n}\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n", "export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n", "export function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n", "import { etherUnits } from '../../constants/unit.js'\n\nimport { formatUnits } from './formatUnits.js'\n\nexport function formatEther(wei: bigint, unit: 'wei' | 'gwei' = 'wei') {\n  return formatUnits(wei, etherUnits[unit])\n}\n", "import { gweiUnits } from '../../constants/unit.js'\n\nimport { formatUnits } from './formatUnits.js'\n\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n", "import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport class FeeConflictError extends BaseError {\n  override name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class InvalidLegacyVError extends BaseError {\n  override name = 'InvalidLegacyVError'\n\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`)\n  }\n}\n\nexport class InvalidSerializableTransactionError extends BaseError {\n  override name = 'InvalidSerializableTransactionError'\n\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n    })\n  }\n}\n\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  override name = 'InvalidSerializedTransactionType'\n\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`)\n\n    this.serializedType = serializedType\n  }\n}\n\nexport class InvalidSerializedTransactionError extends BaseError {\n  override name = 'InvalidSerializedTransactionError'\n\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport class InvalidStorageKeySizeError extends BaseError {\n  override name = 'InvalidStorageKeySizeError'\n\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n    )\n  }\n}\n\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain\n      docsPath?: string\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class TransactionNotFoundError extends BaseError {\n  override name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n    blockTag?: BlockTag\n    hash?: Hash\n    index?: number\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport class TransactionReceiptNotFoundError extends BaseError {\n  override name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  override name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport type { CallParameters } from '../actions/public/call.js'\nimport { panicReasons } from '../constants/solidity.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport {\n  type DecodeErrorResultReturnType,\n  decodeErrorResult,\n} from '../utils/abi/decodeErrorResult.js'\nimport { formatAbiItem } from '../utils/abi/formatAbiItem.js'\nimport { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js'\nimport { getAbiItem } from '../utils/abi/getAbiItem.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\nimport { getContractAddress } from './utils.js'\n\nexport class CallExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'CallExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account: account_,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: CallParameters & { chain?: Chain; docsPath?: string },\n  ) {\n    const account = account_ ? parseAccount(account_) : undefined\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Raw Call Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class ContractFunctionExecutionError extends BaseError {\n  abi: Abi\n  args?: unknown[]\n  override cause: BaseError\n  contractAddress?: Address\n  formattedArgs?: string\n  functionName: string\n  sender?: Address\n\n  override name = 'ContractFunctionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      abi,\n      args,\n      contractAddress,\n      docsPath,\n      functionName,\n      sender,\n    }: {\n      abi: Abi\n      args?: any\n      contractAddress?: Address\n      docsPath?: string\n      functionName: string\n      sender?: Address\n    },\n  ) {\n    const abiItem = getAbiItem({ abi, args, name: functionName })\n    const formattedArgs = abiItem\n      ? formatAbiItemWithArgs({\n          abiItem,\n          args,\n          includeFunctionName: false,\n          includeName: false,\n        })\n      : undefined\n    const functionWithParams = abiItem\n      ? formatAbiItem(abiItem, { includeName: true })\n      : undefined\n\n    const prettyArgs = prettyPrint({\n      address: contractAddress && getContractAddress(contractAddress),\n      function: functionWithParams,\n      args:\n        formattedArgs &&\n        formattedArgs !== '()' &&\n        `${[...Array(functionName?.length ?? 0).keys()]\n          .map(() => ' ')\n          .join('')}${formattedArgs}`,\n      sender,\n    })\n\n    super(\n      cause.shortMessage ||\n        `An unknown error occurred while executing the contract function \"${functionName}\".`,\n      {\n        cause,\n        docsPath,\n        metaMessages: [\n          ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n          'Contract Call:',\n          prettyArgs,\n        ].filter(Boolean) as string[],\n      },\n    )\n    this.abi = abi\n    this.args = args\n    this.cause = cause\n    this.contractAddress = contractAddress\n    this.functionName = functionName\n    this.sender = sender\n  }\n}\n\nexport class ContractFunctionRevertedError extends BaseError {\n  override name = 'ContractFunctionRevertedError'\n\n  data?: DecodeErrorResultReturnType\n  reason?: string\n\n  constructor({\n    abi,\n    data,\n    functionName,\n    message,\n  }: { abi: Abi; data?: Hex; functionName: string; message?: string }) {\n    let decodedData: DecodeErrorResultReturnType | undefined = undefined\n    let metaMessages\n    let reason\n    if (data && data !== '0x') {\n      decodedData = decodeErrorResult({ abi, data })\n      const { abiItem, errorName, args: errorArgs } = decodedData\n      if (errorName === 'Error') {\n        reason = (errorArgs as [string])[0]\n      } else if (errorName === 'Panic') {\n        const [firstArg] = errorArgs as [number]\n        reason = panicReasons[firstArg as keyof typeof panicReasons]\n      } else {\n        const errorWithParams = abiItem\n          ? formatAbiItem(abiItem, { includeName: true })\n          : undefined\n        const formattedArgs =\n          abiItem && errorArgs\n            ? formatAbiItemWithArgs({\n                abiItem,\n                args: errorArgs,\n                includeFunctionName: false,\n                includeName: false,\n              })\n            : undefined\n\n        metaMessages = [\n          errorWithParams ? `Error: ${errorWithParams}` : '',\n          formattedArgs && formattedArgs !== '()'\n            ? `       ${[...Array(errorName?.length ?? 0).keys()]\n                .map(() => ' ')\n                .join('')}${formattedArgs}`\n            : '',\n        ]\n      }\n    } else if (message) reason = message\n\n    super(\n      reason && reason !== 'execution reverted'\n        ? [\n            `The contract function \"${functionName}\" reverted with the following reason:`,\n            reason,\n          ].join('\\n')\n        : `The contract function \"${functionName}\" reverted.`,\n      {\n        metaMessages,\n      },\n    )\n\n    this.reason = reason\n    this.data = decodedData\n  }\n}\n\nexport class ContractFunctionZeroDataError extends BaseError {\n  override name = 'ContractFunctionZeroDataError'\n  constructor({ functionName }: { functionName: string }) {\n    super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n      metaMessages: [\n        'This could be due to any of the following:',\n        `  - The contract does not have the function \"${functionName}\",`,\n        '  - The parameters passed to the contract function may be invalid, or',\n        '  - The address is not a contract.',\n      ],\n    })\n  }\n}\n\nexport class RawContractError extends BaseError {\n  code = 3\n  override name = 'RawContractError'\n\n  data?: Hex | { data?: Hex }\n\n  constructor({\n    data,\n    message,\n  }: { data?: Hex | { data?: Hex }; message?: string }) {\n    super(message || '')\n    this.data = data\n  }\n}\n", "import type { Abi, ExtractAbiFunctionNames, Narrow } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n} from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  ContractFunctionResult,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/decodeFunctionResult'\n\nexport type DecodeFunctionResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n  data: Hex\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & Partial<GetFunctionArgs<TAbi, TFunctionName>>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & Partial<\n      GetFunctionArgs<TAbi, _FunctionName>\n    >\n  : never)\n\nexport type DecodeFunctionResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi>[number]\n    : string,\n> = TFunctionName extends string\n  ? ContractFunctionResult<TAbi, TFunctionName>\n  : ContractFunctionResult<TAbi, _FunctionName>\n\nexport function decodeFunctionResult<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n  data,\n}: DecodeFunctionResultParameters<\n  TAbi,\n  TFunctionName\n>): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = decodeAbiParameters(abiItem.outputs, data)\n  if (values && values.length > 1) return values as any\n  if (values && values.length === 1) return values[0] as any\n  return undefined as any\n}\n", "import type { Abi, Narrow } from 'abitype'\n\nimport { AbiFunctionNotFoundError } from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport { concatHex } from '../data/concat.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeFunctionDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & GetFunctionArgs<TAbi, TFunctionName>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & GetFunctionArgs<TAbi, _FunctionName>\n  : never)\n\nexport function encodeFunctionData<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n}: EncodeFunctionDataParameters<TAbi, TFunctionName>) {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiFunctionNotFoundError(functionName, {\n        docsPath: '/docs/contract/encodeFunctionData',\n      })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeFunctionData',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getFunctionSelector(definition)\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, (args ?? []) as readonly unknown[])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n", "import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\n\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  override name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError; message?: string } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  override name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  override name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  override name = 'NonceTooHighError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage = /nonce too low|transaction already imported/\n  override name = 'NonceTooLowError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  override name = 'NonceMaxValueError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  override name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  override name = 'IntrinsicGasTooHighError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  override name = 'IntrinsicGasTooLowError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  override name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  override name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError\n    maxPriorityFeePerGas?: bigint\n    maxFeePerGas?: bigint\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class UnknownNodeError extends BaseError {\n  override name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError }) {\n    super(`An error occurred while executing: ${cause?.message}`, {\n      cause,\n    })\n  }\n}\n", "import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<TCode extends number = RpcErrorCode> = {\n  code?: TCode | (number & {})\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport class RpcError<TCode extends number = RpcErrorCode> extends BaseError {\n  override name = 'RpcError'\n\n  code: TCode | (number & {})\n\n  constructor(\n    cause: Error,\n    { code, docsPath, metaMessages, shortMessage }: RpcErrorOptions<TCode>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n    })\n    this.name = cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as TCode\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recongnized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  override name = 'ProviderRpcError'\n\n  data?: T\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ParseRpcError extends RpcError {\n  override name = 'ParseRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32700,\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidRequestRpcError extends RpcError {\n  override name = 'InvalidRequestRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32600,\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotFoundRpcError extends RpcError {\n  override name = 'MethodNotFoundRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32601,\n      shortMessage: 'The method does not exist / is not available.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidParamsRpcError extends RpcError {\n  override name = 'InvalidParamsRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32602,\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InternalRpcError extends RpcError {\n  override name = 'InternalRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32603,\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidInputRpcError extends RpcError {\n  override name = 'InvalidInputRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32000,\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32001,\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceUnavailableRpcError extends RpcError {\n  override name = 'ResourceUnavailableRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32002,\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class TransactionRejectedRpcError extends RpcError {\n  override name = 'TransactionRejectedRpcError'\n\n  constructor(cause: Error) {\n    super(cause, { code: -32003, shortMessage: 'Transaction creation failed.' })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotSupportedRpcError extends RpcError {\n  override name = 'MethodNotSupportedRpcError'\n\n  constructor(cause: Error) {\n    super(cause, { code: -32004, shortMessage: 'Method is not implemented.' })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class LimitExceededRpcError extends RpcError {\n  override name = 'LimitExceededRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32005,\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  override name = 'JsonRpcVersionUnsupportedError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: -32006,\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  override name = 'UserRejectedRequestError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4001,\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  override name = 'UnauthorizedProviderError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4100,\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  override name = 'UnsupportedProviderMethodError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4200,\n      shortMessage: 'The Provider does not support the requested method.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  override name = 'ProviderDisconnectedError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4900,\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  override name = 'ChainDisconnectedError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4901,\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class SwitchChainError extends ProviderRpcError {\n  override name = 'SwitchChainError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: 4902,\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport class UnknownRpcError extends RpcError {\n  override name = 'UnknownRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n", "import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  ExecutionRevertedError,\n  FeeCapTooHighError,\n  FeeCapTooLowError,\n  InsufficientFundsError,\n  IntrinsicGasTooHighError,\n  IntrinsicGasTooLowError,\n  NonceMaxValueError,\n  NonceTooHighError,\n  NonceTooLowError,\n  TipAboveFeeCapError,\n  TransactionTypeNotSupportedError,\n  UnknownNodeError,\n} from '../../errors/node.js'\nimport { RpcRequestError } from '../../errors/request.js'\nimport {\n  InvalidInputRpcError,\n  TransactionRejectedRpcError,\n} from '../../errors/rpc.js'\n\nexport function containsNodeError(err: BaseError) {\n  return (\n    err instanceof TransactionRejectedRpcError ||\n    err instanceof InvalidInputRpcError ||\n    (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code)\n  )\n}\n\nexport function getNodeError(\n  err: BaseError,\n  args: Partial<SendTransactionParameters<any>>,\n) {\n  const message = err.details.toLowerCase()\n  if (FeeCapTooHighError.nodeMessage.test(message))\n    return new FeeCapTooHighError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (FeeCapTooLowError.nodeMessage.test(message))\n    return new FeeCapTooLowError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (NonceTooHighError.nodeMessage.test(message))\n    return new NonceTooHighError({ cause: err, nonce: args?.nonce })\n  else if (NonceTooLowError.nodeMessage.test(message))\n    return new NonceTooLowError({ cause: err, nonce: args?.nonce })\n  else if (NonceMaxValueError.nodeMessage.test(message))\n    return new NonceMaxValueError({ cause: err, nonce: args?.nonce })\n  else if (InsufficientFundsError.nodeMessage.test(message))\n    return new InsufficientFundsError({ cause: err })\n  else if (IntrinsicGasTooHighError.nodeMessage.test(message))\n    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas })\n  else if (IntrinsicGasTooLowError.nodeMessage.test(message))\n    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas })\n  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))\n    return new TransactionTypeNotSupportedError({ cause: err })\n  else if (TipAboveFeeCapError.nodeMessage.test(message))\n    return new TipAboveFeeCapError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n      maxPriorityFeePerGas: args?.maxPriorityFeePerGas,\n    })\n  else if (\n    message.match(ExecutionRevertedError.nodeMessage) ||\n    ('code' in (err.cause as BaseError) &&\n      (err.cause as { code: number })?.code === ExecutionRevertedError.code)\n  )\n    return new ExecutionRevertedError({\n      cause: err,\n      message: (err.cause as BaseError).details || err.details,\n    })\n  return new UnknownNodeError({\n    cause: (err.cause as BaseError).cause as BaseError,\n  })\n}\n", "import type { CallParameters } from '../../actions/public/call.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport { containsNodeError, getNodeError } from './getNodeError.js'\n\nexport function getCallError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: CallParameters & {\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err)) cause = getNodeError(err, args)\n  return new CallExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n", "import type { Formatter } from '../../types/formatter.js'\n\n/**\n * @description Picks out the keys from `value` that exist in the formatter.\n */\nexport function extract(\n  value: Record<string, unknown>,\n  { formatter }: { formatter?: Formatter },\n) {\n  if (!formatter) return {}\n  const keys = Object.keys(formatter({}))\n  return keys.reduce((data, key) => {\n    if (value?.hasOwnProperty(key)) {\n      ;(data as any)[key] = value[key]\n    }\n    return data\n  }, {})\n}\n", "type Resolved<TReturnType extends readonly unknown[] = any> = [\n  result: TReturnType[number],\n  results: TReturnType,\n]\n\ntype PendingPromise<TReturnType extends readonly unknown[] = any> = {\n  resolve?: (data: Resolved<TReturnType>) => void\n  reject?: (reason?: unknown) => void\n}\n\ntype SchedulerItem = { args: unknown; pendingPromise: PendingPromise }\n\nexport type CreateBatchSchedulerArguments<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  fn: (args: TParameters[]) => Promise<TReturnType>\n  id: number | string\n  shouldSplitBatch?: (args: TParameters[]) => boolean\n  wait?: number\n}\nexport type CreateBatchSchedulerReturnType<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  flush: () => void\n  schedule: TParameters extends undefined\n    ? (args?: TParameters) => Promise<Resolved<TReturnType>>\n    : (args: TParameters) => Promise<Resolved<TReturnType>>\n}\n\nconst schedulerCache = new Map<number | string, SchedulerItem[]>()\n\nexport function createBatchScheduler<\n  TParameters,\n  TReturnType extends readonly unknown[],\n>({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n}: CreateBatchSchedulerArguments<\n  TParameters,\n  TReturnType\n>): CreateBatchSchedulerReturnType<TParameters, TReturnType> {\n  const exec = async () => {\n    const scheduler = getScheduler()\n    flush()\n\n    const args = scheduler.map(({ args }) => args)\n\n    if (args.length === 0) return\n\n    fn(args as TParameters[])\n      .then((data) => {\n        scheduler.forEach(({ pendingPromise }, i) =>\n          pendingPromise.resolve?.([data[i], data]),\n        )\n      })\n      .catch((err) => {\n        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err))\n      })\n  }\n\n  const flush = () => schedulerCache.delete(id)\n\n  const getBatchedArgs = () =>\n    getScheduler().map(({ args }) => args) as TParameters[]\n\n  const getScheduler = () => schedulerCache.get(id) || []\n\n  const setScheduler = (item: SchedulerItem) =>\n    schedulerCache.set(id, [...getScheduler(), item])\n\n  return {\n    flush,\n    async schedule(args: TParameters) {\n      const pendingPromise: PendingPromise<TReturnType> = {}\n      const promise = new Promise<Resolved<TReturnType>>((resolve, reject) => {\n        pendingPromise.resolve = resolve\n        pendingPromise.reject = reject\n      })\n\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args])\n\n      if (split) exec()\n\n      const hasActiveScheduler = getScheduler().length > 0\n      if (hasActiveScheduler) {\n        setScheduler({ args, pendingPromise })\n        return promise\n      }\n\n      setScheduler({ args, pendingPromise })\n      setTimeout(exec, wait)\n      return promise\n    },\n  } as unknown as CreateBatchSchedulerReturnType<TParameters, TReturnType>\n}\n", "import { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { FeeCapTooHighError, TipAboveFeeCapError } from '../../errors/node.js'\nimport { FeeConflictError } from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport function assertRequest(args: Partial<SendTransactionParameters<Chain>>) {\n  const {\n    account: account_,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    to,\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n  if (account && !isAddress(account.address))\n    throw new InvalidAddressError({ address: account.address })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (\n    typeof gasPrice !== 'undefined' &&\n    (typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined')\n  )\n    throw new FeeConflictError()\n\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { PublicClient } from '../../clients/createPublicClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Formatter } from '../../types/formatter.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { MergeIntersectionProperties } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getCallError } from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport { type Formatted, format } from '../../utils/formatters/format.js'\nimport {\n  type TransactionRequestFormatter,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\n\nexport type FormattedCall<\n  TFormatter extends Formatter | undefined = Formatter,\n> = MergeIntersectionProperties<\n  Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>,\n  TransactionRequest\n>\n\nexport type CallParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedCall<TransactionRequestFormatter<TChain>> & {\n  account?: Account | Address\n  batch?: boolean\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call.html\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<TChain extends Chain | undefined>(\n  client: PublicClient<Transport, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const formatter = client.chain?.formatters?.transactionRequest\n    const request = format(\n      {\n        from: account?.address,\n        accessList,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { formatter }),\n      } as TransactionRequest,\n      {\n        formatter: formatter || formatTransactionRequest,\n      },\n    ) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request })) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<TChain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: block\n        ? [request as Partial<RpcTransactionRequest>, block]\n        : [request as Partial<RpcTransactionRequest>],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (data?.slice(0, 10) === offchainLookupSignature && to) {\n      return { data: await offchainLookup(client, { data, to }) }\n    }\n    throw getCallError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<TChain extends Chain | undefined> = Pick<\n  CallParameters<TChain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address\n  to: Address\n}\n\nasync function scheduleMulticall<TChain extends Chain | undefined>(\n  client: PublicClient<Transport, TChain>,\n  args: ScheduleMulticallParameters<TChain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch?.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error.data === 'object' ? error.data.data : error.data\n}\n"],
  "mappings": "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",
  "names": ["docsPath", "size", "docsPath", "size", "docsPath", "length", "toBytes", "hash", "length", "consumed", "value", "size", "value", "docsPath", "hash", "docsPath", "docsPath", "docsPath", "args", "split", "data", "args", "size"]
}
